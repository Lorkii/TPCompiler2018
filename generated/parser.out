Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement ; programme
Rule 2     programme -> structure programme
Rule 3     programme -> statement ;
Rule 4     programme -> structure
Rule 5     statement -> assignation
Rule 6     statement -> funcCall
Rule 7     params -> IDENTIFIER , params
Rule 8     params -> IDENTIFIER
Rule 9     params -> <empty>
Rule 10    structure -> funcDec
Rule 11    funcDec -> FUN IDENTIFIER ( params ) { programme RETURN }
Rule 12    paramsCall -> expression , paramsCall
Rule 13    paramsCall -> expression
Rule 14    paramsCall -> <empty>
Rule 15    funcCall -> IDENTIFIER ( paramsCall )
Rule 16    statement -> PRINT expression
Rule 17    structure -> WHILE expression { programme }
Rule 18    structure -> IF expression { programme }
Rule 19    expression -> STRING + STRING
Rule 20    expression -> expression ADD_OP expression
Rule 21    expression -> expression MUL_OP expression
Rule 22    expression -> expression COMP_OP expression
Rule 23    expression -> NUMBER
Rule 24    expression -> IDENTIFIER
Rule 25    expression -> BOOLEAN
Rule 26    expression -> STRING
Rule 27    expression -> ( expression )
Rule 28    expression -> ADD_OP expression
Rule 29    assignation -> IDENTIFIER = expression
Rule 30    assignation -> GLOBAL IDENTIFIER = expression

Terminals, with rules where they appear

(                    : 11 15 27
)                    : 11 15 27
+                    : 19
,                    : 7 12
;                    : 1 3
=                    : 29 30
ADD_OP               : 20 28
BOOLEAN              : 25
COMP_OP              : 22
FUN                  : 11
GLOBAL               : 30
IDENTIFIER           : 7 8 11 15 24 29 30
IF                   : 18
MUL_OP               : 21
NUMBER               : 23
PRINT                : 16
RETURN               : 11
STRING               : 19 19 26
WHILE                : 17
error                : 
{                    : 11 17 18
}                    : 11 17 18

Nonterminals, with rules where they appear

assignation          : 5
expression           : 12 13 16 17 18 20 20 21 21 22 22 27 28 29 30
funcCall             : 6
funcDec              : 10
params               : 7 11
paramsCall           : 12 15
programme            : 1 2 11 17 18 0
statement            : 1 3
structure            : 2 4

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (16) statement -> . PRINT expression
    (10) structure -> . funcDec
    (17) structure -> . WHILE expression { programme }
    (18) structure -> . IF expression { programme }
    (29) assignation -> . IDENTIFIER = expression
    (30) assignation -> . GLOBAL IDENTIFIER = expression
    (15) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement . ; programme
    (3) programme -> statement . ;

    ;               shift and go to state 13


state 3

    (2) programme -> structure . programme
    (4) programme -> structure .
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (16) statement -> . PRINT expression
    (10) structure -> . funcDec
    (17) structure -> . WHILE expression { programme }
    (18) structure -> . IF expression { programme }
    (29) assignation -> . IDENTIFIER = expression
    (30) assignation -> . GLOBAL IDENTIFIER = expression
    (15) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN }

    $end            reduce using rule 4 (programme -> structure .)
    }               reduce using rule 4 (programme -> structure .)
    RETURN          reduce using rule 4 (programme -> structure .)
    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    structure                      shift and go to state 3
    programme                      shift and go to state 14
    statement                      shift and go to state 2
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 4

    (5) statement -> assignation .

    ;               reduce using rule 5 (statement -> assignation .)


state 5

    (6) statement -> funcCall .

    ;               reduce using rule 6 (statement -> funcCall .)


state 6

    (16) statement -> PRINT . expression
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 15

state 7

    (10) structure -> funcDec .

    PRINT           reduce using rule 10 (structure -> funcDec .)
    WHILE           reduce using rule 10 (structure -> funcDec .)
    IF              reduce using rule 10 (structure -> funcDec .)
    IDENTIFIER      reduce using rule 10 (structure -> funcDec .)
    GLOBAL          reduce using rule 10 (structure -> funcDec .)
    FUN             reduce using rule 10 (structure -> funcDec .)
    $end            reduce using rule 10 (structure -> funcDec .)
    }               reduce using rule 10 (structure -> funcDec .)
    RETURN          reduce using rule 10 (structure -> funcDec .)


state 8

    (17) structure -> WHILE . expression { programme }
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 22

state 9

    (18) structure -> IF . expression { programme }
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 23

state 10

    (29) assignation -> IDENTIFIER . = expression
    (15) funcCall -> IDENTIFIER . ( paramsCall )

    =               shift and go to state 24
    (               shift and go to state 25


state 11

    (30) assignation -> GLOBAL . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 26


state 12

    (11) funcDec -> FUN . IDENTIFIER ( params ) { programme RETURN }

    IDENTIFIER      shift and go to state 27


state 13

    (1) programme -> statement ; . programme
    (3) programme -> statement ; .
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (16) statement -> . PRINT expression
    (10) structure -> . funcDec
    (17) structure -> . WHILE expression { programme }
    (18) structure -> . IF expression { programme }
    (29) assignation -> . IDENTIFIER = expression
    (30) assignation -> . GLOBAL IDENTIFIER = expression
    (15) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN }

    $end            reduce using rule 3 (programme -> statement ; .)
    }               reduce using rule 3 (programme -> statement ; .)
    RETURN          reduce using rule 3 (programme -> statement ; .)
    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    statement                      shift and go to state 2
    programme                      shift and go to state 28
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 14

    (2) programme -> structure programme .

    $end            reduce using rule 2 (programme -> structure programme .)
    }               reduce using rule 2 (programme -> structure programme .)
    RETURN          reduce using rule 2 (programme -> structure programme .)


state 15

    (16) statement -> PRINT expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    ;               reduce using rule 16 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 16

    (19) expression -> STRING . + STRING
    (26) expression -> STRING .

    +               shift and go to state 32
    ADD_OP          reduce using rule 26 (expression -> STRING .)
    MUL_OP          reduce using rule 26 (expression -> STRING .)
    COMP_OP         reduce using rule 26 (expression -> STRING .)
    ;               reduce using rule 26 (expression -> STRING .)
    {               reduce using rule 26 (expression -> STRING .)
    )               reduce using rule 26 (expression -> STRING .)
    ,               reduce using rule 26 (expression -> STRING .)


state 17

    (28) expression -> ADD_OP . expression
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 33

state 18

    (23) expression -> NUMBER .

    ADD_OP          reduce using rule 23 (expression -> NUMBER .)
    MUL_OP          reduce using rule 23 (expression -> NUMBER .)
    COMP_OP         reduce using rule 23 (expression -> NUMBER .)
    ;               reduce using rule 23 (expression -> NUMBER .)
    {               reduce using rule 23 (expression -> NUMBER .)
    )               reduce using rule 23 (expression -> NUMBER .)
    ,               reduce using rule 23 (expression -> NUMBER .)


state 19

    (24) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 24 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 24 (expression -> IDENTIFIER .)
    COMP_OP         reduce using rule 24 (expression -> IDENTIFIER .)
    ;               reduce using rule 24 (expression -> IDENTIFIER .)
    {               reduce using rule 24 (expression -> IDENTIFIER .)
    )               reduce using rule 24 (expression -> IDENTIFIER .)
    ,               reduce using rule 24 (expression -> IDENTIFIER .)


state 20

    (25) expression -> BOOLEAN .

    ADD_OP          reduce using rule 25 (expression -> BOOLEAN .)
    MUL_OP          reduce using rule 25 (expression -> BOOLEAN .)
    COMP_OP         reduce using rule 25 (expression -> BOOLEAN .)
    ;               reduce using rule 25 (expression -> BOOLEAN .)
    {               reduce using rule 25 (expression -> BOOLEAN .)
    )               reduce using rule 25 (expression -> BOOLEAN .)
    ,               reduce using rule 25 (expression -> BOOLEAN .)


state 21

    (27) expression -> ( . expression )
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 34

state 22

    (17) structure -> WHILE expression . { programme }
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    {               shift and go to state 35
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 23

    (18) structure -> IF expression . { programme }
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    {               shift and go to state 36
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 24

    (29) assignation -> IDENTIFIER = . expression
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 37

state 25

    (15) funcCall -> IDENTIFIER ( . paramsCall )
    (12) paramsCall -> . expression , paramsCall
    (13) paramsCall -> . expression
    (14) paramsCall -> .
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    )               reduce using rule 14 (paramsCall -> .)
    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    paramsCall                     shift and go to state 38
    expression                     shift and go to state 39

state 26

    (30) assignation -> GLOBAL IDENTIFIER . = expression

    =               shift and go to state 40


state 27

    (11) funcDec -> FUN IDENTIFIER . ( params ) { programme RETURN }

    (               shift and go to state 41


state 28

    (1) programme -> statement ; programme .

    $end            reduce using rule 1 (programme -> statement ; programme .)
    }               reduce using rule 1 (programme -> statement ; programme .)
    RETURN          reduce using rule 1 (programme -> statement ; programme .)


state 29

    (20) expression -> expression ADD_OP . expression
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 42

state 30

    (21) expression -> expression MUL_OP . expression
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 43

state 31

    (22) expression -> expression COMP_OP . expression
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 44

state 32

    (19) expression -> STRING + . STRING

    STRING          shift and go to state 45


state 33

    (28) expression -> ADD_OP expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 28 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 28 (expression -> ADD_OP expression .)
    COMP_OP         reduce using rule 28 (expression -> ADD_OP expression .)
    ;               reduce using rule 28 (expression -> ADD_OP expression .)
    {               reduce using rule 28 (expression -> ADD_OP expression .)
    )               reduce using rule 28 (expression -> ADD_OP expression .)
    ,               reduce using rule 28 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 29 ]
  ! MUL_OP          [ shift and go to state 30 ]
  ! COMP_OP         [ shift and go to state 31 ]


state 34

    (27) expression -> ( expression . )
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    )               shift and go to state 46
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 35

    (17) structure -> WHILE expression { . programme }
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (16) statement -> . PRINT expression
    (10) structure -> . funcDec
    (17) structure -> . WHILE expression { programme }
    (18) structure -> . IF expression { programme }
    (29) assignation -> . IDENTIFIER = expression
    (30) assignation -> . GLOBAL IDENTIFIER = expression
    (15) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 47
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 36

    (18) structure -> IF expression { . programme }
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (16) statement -> . PRINT expression
    (10) structure -> . funcDec
    (17) structure -> . WHILE expression { programme }
    (18) structure -> . IF expression { programme }
    (29) assignation -> . IDENTIFIER = expression
    (30) assignation -> . GLOBAL IDENTIFIER = expression
    (15) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 48
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 37

    (29) assignation -> IDENTIFIER = expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    ;               reduce using rule 29 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 38

    (15) funcCall -> IDENTIFIER ( paramsCall . )

    )               shift and go to state 49


state 39

    (12) paramsCall -> expression . , paramsCall
    (13) paramsCall -> expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    ,               shift and go to state 50
    )               reduce using rule 13 (paramsCall -> expression .)
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 40

    (30) assignation -> GLOBAL IDENTIFIER = . expression
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 51

state 41

    (11) funcDec -> FUN IDENTIFIER ( . params ) { programme RETURN }
    (7) params -> . IDENTIFIER , params
    (8) params -> . IDENTIFIER
    (9) params -> .

    IDENTIFIER      shift and go to state 52
    )               reduce using rule 9 (params -> .)

    params                         shift and go to state 53

state 42

    (20) expression -> expression ADD_OP expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 20 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 20 (expression -> expression ADD_OP expression .)
    {               reduce using rule 20 (expression -> expression ADD_OP expression .)
    )               reduce using rule 20 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 20 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31

  ! MUL_OP          [ reduce using rule 20 (expression -> expression ADD_OP expression .) ]
  ! COMP_OP         [ reduce using rule 20 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 29 ]


state 43

    (21) expression -> expression MUL_OP expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 21 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 21 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 21 (expression -> expression MUL_OP expression .)
    {               reduce using rule 21 (expression -> expression MUL_OP expression .)
    )               reduce using rule 21 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 21 (expression -> expression MUL_OP expression .)
    COMP_OP         shift and go to state 31

  ! COMP_OP         [ reduce using rule 21 (expression -> expression MUL_OP expression .) ]
  ! ADD_OP          [ shift and go to state 29 ]
  ! MUL_OP          [ shift and go to state 30 ]


state 44

    (22) expression -> expression COMP_OP expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 22 (expression -> expression COMP_OP expression .)
    MUL_OP          reduce using rule 22 (expression -> expression COMP_OP expression .)
    COMP_OP         reduce using rule 22 (expression -> expression COMP_OP expression .)
    ;               reduce using rule 22 (expression -> expression COMP_OP expression .)
    {               reduce using rule 22 (expression -> expression COMP_OP expression .)
    )               reduce using rule 22 (expression -> expression COMP_OP expression .)
    ,               reduce using rule 22 (expression -> expression COMP_OP expression .)

  ! ADD_OP          [ shift and go to state 29 ]
  ! MUL_OP          [ shift and go to state 30 ]
  ! COMP_OP         [ shift and go to state 31 ]


state 45

    (19) expression -> STRING + STRING .

    ADD_OP          reduce using rule 19 (expression -> STRING + STRING .)
    MUL_OP          reduce using rule 19 (expression -> STRING + STRING .)
    COMP_OP         reduce using rule 19 (expression -> STRING + STRING .)
    ;               reduce using rule 19 (expression -> STRING + STRING .)
    {               reduce using rule 19 (expression -> STRING + STRING .)
    )               reduce using rule 19 (expression -> STRING + STRING .)
    ,               reduce using rule 19 (expression -> STRING + STRING .)


state 46

    (27) expression -> ( expression ) .

    ADD_OP          reduce using rule 27 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 27 (expression -> ( expression ) .)
    COMP_OP         reduce using rule 27 (expression -> ( expression ) .)
    ;               reduce using rule 27 (expression -> ( expression ) .)
    {               reduce using rule 27 (expression -> ( expression ) .)
    )               reduce using rule 27 (expression -> ( expression ) .)
    ,               reduce using rule 27 (expression -> ( expression ) .)


state 47

    (17) structure -> WHILE expression { programme . }

    }               shift and go to state 54


state 48

    (18) structure -> IF expression { programme . }

    }               shift and go to state 55


state 49

    (15) funcCall -> IDENTIFIER ( paramsCall ) .

    ;               reduce using rule 15 (funcCall -> IDENTIFIER ( paramsCall ) .)


state 50

    (12) paramsCall -> expression , . paramsCall
    (12) paramsCall -> . expression , paramsCall
    (13) paramsCall -> . expression
    (14) paramsCall -> .
    (19) expression -> . STRING + STRING
    (20) expression -> . expression ADD_OP expression
    (21) expression -> . expression MUL_OP expression
    (22) expression -> . expression COMP_OP expression
    (23) expression -> . NUMBER
    (24) expression -> . IDENTIFIER
    (25) expression -> . BOOLEAN
    (26) expression -> . STRING
    (27) expression -> . ( expression )
    (28) expression -> . ADD_OP expression

    )               reduce using rule 14 (paramsCall -> .)
    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 39
    paramsCall                     shift and go to state 56

state 51

    (30) assignation -> GLOBAL IDENTIFIER = expression .
    (20) expression -> expression . ADD_OP expression
    (21) expression -> expression . MUL_OP expression
    (22) expression -> expression . COMP_OP expression

    ;               reduce using rule 30 (assignation -> GLOBAL IDENTIFIER = expression .)
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 52

    (7) params -> IDENTIFIER . , params
    (8) params -> IDENTIFIER .

    ,               shift and go to state 57
    )               reduce using rule 8 (params -> IDENTIFIER .)


state 53

    (11) funcDec -> FUN IDENTIFIER ( params . ) { programme RETURN }

    )               shift and go to state 58


state 54

    (17) structure -> WHILE expression { programme } .

    PRINT           reduce using rule 17 (structure -> WHILE expression { programme } .)
    WHILE           reduce using rule 17 (structure -> WHILE expression { programme } .)
    IF              reduce using rule 17 (structure -> WHILE expression { programme } .)
    IDENTIFIER      reduce using rule 17 (structure -> WHILE expression { programme } .)
    GLOBAL          reduce using rule 17 (structure -> WHILE expression { programme } .)
    FUN             reduce using rule 17 (structure -> WHILE expression { programme } .)
    $end            reduce using rule 17 (structure -> WHILE expression { programme } .)
    }               reduce using rule 17 (structure -> WHILE expression { programme } .)
    RETURN          reduce using rule 17 (structure -> WHILE expression { programme } .)


state 55

    (18) structure -> IF expression { programme } .

    PRINT           reduce using rule 18 (structure -> IF expression { programme } .)
    WHILE           reduce using rule 18 (structure -> IF expression { programme } .)
    IF              reduce using rule 18 (structure -> IF expression { programme } .)
    IDENTIFIER      reduce using rule 18 (structure -> IF expression { programme } .)
    GLOBAL          reduce using rule 18 (structure -> IF expression { programme } .)
    FUN             reduce using rule 18 (structure -> IF expression { programme } .)
    $end            reduce using rule 18 (structure -> IF expression { programme } .)
    }               reduce using rule 18 (structure -> IF expression { programme } .)
    RETURN          reduce using rule 18 (structure -> IF expression { programme } .)


state 56

    (12) paramsCall -> expression , paramsCall .

    )               reduce using rule 12 (paramsCall -> expression , paramsCall .)


state 57

    (7) params -> IDENTIFIER , . params
    (7) params -> . IDENTIFIER , params
    (8) params -> . IDENTIFIER
    (9) params -> .

    IDENTIFIER      shift and go to state 52
    )               reduce using rule 9 (params -> .)

    params                         shift and go to state 59

state 58

    (11) funcDec -> FUN IDENTIFIER ( params ) . { programme RETURN }

    {               shift and go to state 60


state 59

    (7) params -> IDENTIFIER , params .

    )               reduce using rule 7 (params -> IDENTIFIER , params .)


state 60

    (11) funcDec -> FUN IDENTIFIER ( params ) { . programme RETURN }
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (16) statement -> . PRINT expression
    (10) structure -> . funcDec
    (17) structure -> . WHILE expression { programme }
    (18) structure -> . IF expression { programme }
    (29) assignation -> . IDENTIFIER = expression
    (30) assignation -> . GLOBAL IDENTIFIER = expression
    (15) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 61
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 61

    (11) funcDec -> FUN IDENTIFIER ( params ) { programme . RETURN }

    RETURN          shift and go to state 62


state 62

    (11) funcDec -> FUN IDENTIFIER ( params ) { programme RETURN . }

    }               shift and go to state 63


state 63

    (11) funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .

    PRINT           reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .)
    WHILE           reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .)
    IF              reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .)
    IDENTIFIER      reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .)
    GLOBAL          reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .)
    FUN             reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .)
    $end            reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .)
    }               reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .)
    RETURN          reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN } .)

