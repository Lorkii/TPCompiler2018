Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement ; programme
Rule 2     programme -> structure programme
Rule 3     programme -> statement ;
Rule 4     programme -> structure
Rule 5     statement -> assignation
Rule 6     statement -> funcCall
Rule 7     params -> IDENTIFIER , params
Rule 8     params -> IDENTIFIER
Rule 9     params -> <empty>
Rule 10    structure -> funcDec
Rule 11    funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; }
Rule 12    funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; }
Rule 13    paramsCall -> expression , paramsCall
Rule 14    paramsCall -> expression
Rule 15    paramsCall -> <empty>
Rule 16    funcCall -> IDENTIFIER ( paramsCall )
Rule 17    statement -> PRINT expression
Rule 18    structure -> WHILE expression { programme }
Rule 19    structure -> IF expression { programme }
Rule 20    expression -> funcCall
Rule 21    expression -> STRING + STRING
Rule 22    expression -> expression ADD_OP expression
Rule 23    expression -> expression MUL_OP expression
Rule 24    expression -> expression COMP_OP expression
Rule 25    expression -> NUMBER
Rule 26    expression -> IDENTIFIER
Rule 27    expression -> BOOLEAN
Rule 28    expression -> STRING
Rule 29    expression -> ( expression )
Rule 30    expression -> ADD_OP expression
Rule 31    assignation -> IDENTIFIER = expression
Rule 32    assignation -> GLOBAL IDENTIFIER = expression

Terminals, with rules where they appear

(                    : 11 12 16 29
)                    : 11 12 16 29
+                    : 21
,                    : 7 13
;                    : 1 3 11 12
=                    : 31 32
ADD_OP               : 22 30
BOOLEAN              : 27
COMP_OP              : 24
FUN                  : 11 12
GLOBAL               : 32
IDENTIFIER           : 7 8 11 12 16 26 31 32
IF                   : 19
MUL_OP               : 23
NUMBER               : 25
PRINT                : 17
RETURN               : 11 12
STRING               : 21 21 28
WHILE                : 18
error                : 
{                    : 11 12 18 19
}                    : 11 12 18 19

Nonterminals, with rules where they appear

assignation          : 5
expression           : 11 12 13 14 17 18 19 22 22 23 23 24 24 29 30 31 32
funcCall             : 6 20
funcDec              : 10
params               : 7 11 12
paramsCall           : 13 16
programme            : 1 2 11 18 19 0
statement            : 1 3
structure            : 2 4

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (17) statement -> . PRINT expression
    (10) structure -> . funcDec
    (18) structure -> . WHILE expression { programme }
    (19) structure -> . IF expression { programme }
    (31) assignation -> . IDENTIFIER = expression
    (32) assignation -> . GLOBAL IDENTIFIER = expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN expression ; }
    (12) funcDec -> . FUN IDENTIFIER ( params ) { RETURN expression ; }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement . ; programme
    (3) programme -> statement . ;

    ;               shift and go to state 13


state 3

    (2) programme -> structure . programme
    (4) programme -> structure .
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (17) statement -> . PRINT expression
    (10) structure -> . funcDec
    (18) structure -> . WHILE expression { programme }
    (19) structure -> . IF expression { programme }
    (31) assignation -> . IDENTIFIER = expression
    (32) assignation -> . GLOBAL IDENTIFIER = expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN expression ; }
    (12) funcDec -> . FUN IDENTIFIER ( params ) { RETURN expression ; }

    $end            reduce using rule 4 (programme -> structure .)
    }               reduce using rule 4 (programme -> structure .)
    RETURN          reduce using rule 4 (programme -> structure .)
    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    structure                      shift and go to state 3
    programme                      shift and go to state 14
    statement                      shift and go to state 2
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 4

    (5) statement -> assignation .

    ;               reduce using rule 5 (statement -> assignation .)


state 5

    (6) statement -> funcCall .

    ;               reduce using rule 6 (statement -> funcCall .)


state 6

    (17) statement -> PRINT . expression
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 15
    funcCall                       shift and go to state 16

state 7

    (10) structure -> funcDec .

    PRINT           reduce using rule 10 (structure -> funcDec .)
    WHILE           reduce using rule 10 (structure -> funcDec .)
    IF              reduce using rule 10 (structure -> funcDec .)
    IDENTIFIER      reduce using rule 10 (structure -> funcDec .)
    GLOBAL          reduce using rule 10 (structure -> funcDec .)
    FUN             reduce using rule 10 (structure -> funcDec .)
    $end            reduce using rule 10 (structure -> funcDec .)
    }               reduce using rule 10 (structure -> funcDec .)
    RETURN          reduce using rule 10 (structure -> funcDec .)


state 8

    (18) structure -> WHILE . expression { programme }
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 23
    funcCall                       shift and go to state 16

state 9

    (19) structure -> IF . expression { programme }
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 24
    funcCall                       shift and go to state 16

state 10

    (31) assignation -> IDENTIFIER . = expression
    (16) funcCall -> IDENTIFIER . ( paramsCall )

    =               shift and go to state 25
    (               shift and go to state 26


state 11

    (32) assignation -> GLOBAL . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 27


state 12

    (11) funcDec -> FUN . IDENTIFIER ( params ) { programme RETURN expression ; }
    (12) funcDec -> FUN . IDENTIFIER ( params ) { RETURN expression ; }

    IDENTIFIER      shift and go to state 28


state 13

    (1) programme -> statement ; . programme
    (3) programme -> statement ; .
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (17) statement -> . PRINT expression
    (10) structure -> . funcDec
    (18) structure -> . WHILE expression { programme }
    (19) structure -> . IF expression { programme }
    (31) assignation -> . IDENTIFIER = expression
    (32) assignation -> . GLOBAL IDENTIFIER = expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN expression ; }
    (12) funcDec -> . FUN IDENTIFIER ( params ) { RETURN expression ; }

    $end            reduce using rule 3 (programme -> statement ; .)
    }               reduce using rule 3 (programme -> statement ; .)
    RETURN          reduce using rule 3 (programme -> statement ; .)
    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    statement                      shift and go to state 2
    programme                      shift and go to state 29
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 14

    (2) programme -> structure programme .

    $end            reduce using rule 2 (programme -> structure programme .)
    }               reduce using rule 2 (programme -> structure programme .)
    RETURN          reduce using rule 2 (programme -> structure programme .)


state 15

    (17) statement -> PRINT expression .
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ;               reduce using rule 17 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32


state 16

    (20) expression -> funcCall .

    ADD_OP          reduce using rule 20 (expression -> funcCall .)
    MUL_OP          reduce using rule 20 (expression -> funcCall .)
    COMP_OP         reduce using rule 20 (expression -> funcCall .)
    ;               reduce using rule 20 (expression -> funcCall .)
    {               reduce using rule 20 (expression -> funcCall .)
    )               reduce using rule 20 (expression -> funcCall .)
    ,               reduce using rule 20 (expression -> funcCall .)


state 17

    (21) expression -> STRING . + STRING
    (28) expression -> STRING .

    +               shift and go to state 33
    ADD_OP          reduce using rule 28 (expression -> STRING .)
    MUL_OP          reduce using rule 28 (expression -> STRING .)
    COMP_OP         reduce using rule 28 (expression -> STRING .)
    ;               reduce using rule 28 (expression -> STRING .)
    {               reduce using rule 28 (expression -> STRING .)
    )               reduce using rule 28 (expression -> STRING .)
    ,               reduce using rule 28 (expression -> STRING .)


state 18

    (30) expression -> ADD_OP . expression
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 34
    funcCall                       shift and go to state 16

state 19

    (25) expression -> NUMBER .

    ADD_OP          reduce using rule 25 (expression -> NUMBER .)
    MUL_OP          reduce using rule 25 (expression -> NUMBER .)
    COMP_OP         reduce using rule 25 (expression -> NUMBER .)
    ;               reduce using rule 25 (expression -> NUMBER .)
    {               reduce using rule 25 (expression -> NUMBER .)
    )               reduce using rule 25 (expression -> NUMBER .)
    ,               reduce using rule 25 (expression -> NUMBER .)


state 20

    (26) expression -> IDENTIFIER .
    (16) funcCall -> IDENTIFIER . ( paramsCall )

    ADD_OP          reduce using rule 26 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 26 (expression -> IDENTIFIER .)
    COMP_OP         reduce using rule 26 (expression -> IDENTIFIER .)
    ;               reduce using rule 26 (expression -> IDENTIFIER .)
    {               reduce using rule 26 (expression -> IDENTIFIER .)
    )               reduce using rule 26 (expression -> IDENTIFIER .)
    ,               reduce using rule 26 (expression -> IDENTIFIER .)
    (               shift and go to state 26


state 21

    (27) expression -> BOOLEAN .

    ADD_OP          reduce using rule 27 (expression -> BOOLEAN .)
    MUL_OP          reduce using rule 27 (expression -> BOOLEAN .)
    COMP_OP         reduce using rule 27 (expression -> BOOLEAN .)
    ;               reduce using rule 27 (expression -> BOOLEAN .)
    {               reduce using rule 27 (expression -> BOOLEAN .)
    )               reduce using rule 27 (expression -> BOOLEAN .)
    ,               reduce using rule 27 (expression -> BOOLEAN .)


state 22

    (29) expression -> ( . expression )
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 35
    funcCall                       shift and go to state 16

state 23

    (18) structure -> WHILE expression . { programme }
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    {               shift and go to state 36
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32


state 24

    (19) structure -> IF expression . { programme }
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    {               shift and go to state 37
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32


state 25

    (31) assignation -> IDENTIFIER = . expression
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 38
    funcCall                       shift and go to state 16

state 26

    (16) funcCall -> IDENTIFIER ( . paramsCall )
    (13) paramsCall -> . expression , paramsCall
    (14) paramsCall -> . expression
    (15) paramsCall -> .
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    )               reduce using rule 15 (paramsCall -> .)
    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    paramsCall                     shift and go to state 39
    expression                     shift and go to state 40
    funcCall                       shift and go to state 16

state 27

    (32) assignation -> GLOBAL IDENTIFIER . = expression

    =               shift and go to state 41


state 28

    (11) funcDec -> FUN IDENTIFIER . ( params ) { programme RETURN expression ; }
    (12) funcDec -> FUN IDENTIFIER . ( params ) { RETURN expression ; }

    (               shift and go to state 42


state 29

    (1) programme -> statement ; programme .

    $end            reduce using rule 1 (programme -> statement ; programme .)
    }               reduce using rule 1 (programme -> statement ; programme .)
    RETURN          reduce using rule 1 (programme -> statement ; programme .)


state 30

    (22) expression -> expression ADD_OP . expression
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 43
    funcCall                       shift and go to state 16

state 31

    (23) expression -> expression MUL_OP . expression
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 44
    funcCall                       shift and go to state 16

state 32

    (24) expression -> expression COMP_OP . expression
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 45
    funcCall                       shift and go to state 16

state 33

    (21) expression -> STRING + . STRING

    STRING          shift and go to state 46


state 34

    (30) expression -> ADD_OP expression .
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 30 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 30 (expression -> ADD_OP expression .)
    COMP_OP         reduce using rule 30 (expression -> ADD_OP expression .)
    ;               reduce using rule 30 (expression -> ADD_OP expression .)
    {               reduce using rule 30 (expression -> ADD_OP expression .)
    )               reduce using rule 30 (expression -> ADD_OP expression .)
    ,               reduce using rule 30 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 30 ]
  ! MUL_OP          [ shift and go to state 31 ]
  ! COMP_OP         [ shift and go to state 32 ]


state 35

    (29) expression -> ( expression . )
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    )               shift and go to state 47
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32


state 36

    (18) structure -> WHILE expression { . programme }
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (17) statement -> . PRINT expression
    (10) structure -> . funcDec
    (18) structure -> . WHILE expression { programme }
    (19) structure -> . IF expression { programme }
    (31) assignation -> . IDENTIFIER = expression
    (32) assignation -> . GLOBAL IDENTIFIER = expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN expression ; }
    (12) funcDec -> . FUN IDENTIFIER ( params ) { RETURN expression ; }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 48
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 37

    (19) structure -> IF expression { . programme }
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (17) statement -> . PRINT expression
    (10) structure -> . funcDec
    (18) structure -> . WHILE expression { programme }
    (19) structure -> . IF expression { programme }
    (31) assignation -> . IDENTIFIER = expression
    (32) assignation -> . GLOBAL IDENTIFIER = expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN expression ; }
    (12) funcDec -> . FUN IDENTIFIER ( params ) { RETURN expression ; }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 49
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 38

    (31) assignation -> IDENTIFIER = expression .
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ;               reduce using rule 31 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32


state 39

    (16) funcCall -> IDENTIFIER ( paramsCall . )

    )               shift and go to state 50


state 40

    (13) paramsCall -> expression . , paramsCall
    (14) paramsCall -> expression .
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ,               shift and go to state 51
    )               reduce using rule 14 (paramsCall -> expression .)
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32


state 41

    (32) assignation -> GLOBAL IDENTIFIER = . expression
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 52
    funcCall                       shift and go to state 16

state 42

    (11) funcDec -> FUN IDENTIFIER ( . params ) { programme RETURN expression ; }
    (12) funcDec -> FUN IDENTIFIER ( . params ) { RETURN expression ; }
    (7) params -> . IDENTIFIER , params
    (8) params -> . IDENTIFIER
    (9) params -> .

    IDENTIFIER      shift and go to state 53
    )               reduce using rule 9 (params -> .)

    params                         shift and go to state 54

state 43

    (22) expression -> expression ADD_OP expression .
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 22 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 22 (expression -> expression ADD_OP expression .)
    {               reduce using rule 22 (expression -> expression ADD_OP expression .)
    )               reduce using rule 22 (expression -> expression ADD_OP expression .)
    ,               reduce using rule 22 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32

  ! MUL_OP          [ reduce using rule 22 (expression -> expression ADD_OP expression .) ]
  ! COMP_OP         [ reduce using rule 22 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 30 ]


state 44

    (23) expression -> expression MUL_OP expression .
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 23 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 23 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 23 (expression -> expression MUL_OP expression .)
    {               reduce using rule 23 (expression -> expression MUL_OP expression .)
    )               reduce using rule 23 (expression -> expression MUL_OP expression .)
    ,               reduce using rule 23 (expression -> expression MUL_OP expression .)
    COMP_OP         shift and go to state 32

  ! COMP_OP         [ reduce using rule 23 (expression -> expression MUL_OP expression .) ]
  ! ADD_OP          [ shift and go to state 30 ]
  ! MUL_OP          [ shift and go to state 31 ]


state 45

    (24) expression -> expression COMP_OP expression .
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 24 (expression -> expression COMP_OP expression .)
    MUL_OP          reduce using rule 24 (expression -> expression COMP_OP expression .)
    COMP_OP         reduce using rule 24 (expression -> expression COMP_OP expression .)
    ;               reduce using rule 24 (expression -> expression COMP_OP expression .)
    {               reduce using rule 24 (expression -> expression COMP_OP expression .)
    )               reduce using rule 24 (expression -> expression COMP_OP expression .)
    ,               reduce using rule 24 (expression -> expression COMP_OP expression .)

  ! ADD_OP          [ shift and go to state 30 ]
  ! MUL_OP          [ shift and go to state 31 ]
  ! COMP_OP         [ shift and go to state 32 ]


state 46

    (21) expression -> STRING + STRING .

    ADD_OP          reduce using rule 21 (expression -> STRING + STRING .)
    MUL_OP          reduce using rule 21 (expression -> STRING + STRING .)
    COMP_OP         reduce using rule 21 (expression -> STRING + STRING .)
    ;               reduce using rule 21 (expression -> STRING + STRING .)
    {               reduce using rule 21 (expression -> STRING + STRING .)
    )               reduce using rule 21 (expression -> STRING + STRING .)
    ,               reduce using rule 21 (expression -> STRING + STRING .)


state 47

    (29) expression -> ( expression ) .

    ADD_OP          reduce using rule 29 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 29 (expression -> ( expression ) .)
    COMP_OP         reduce using rule 29 (expression -> ( expression ) .)
    ;               reduce using rule 29 (expression -> ( expression ) .)
    {               reduce using rule 29 (expression -> ( expression ) .)
    )               reduce using rule 29 (expression -> ( expression ) .)
    ,               reduce using rule 29 (expression -> ( expression ) .)


state 48

    (18) structure -> WHILE expression { programme . }

    }               shift and go to state 55


state 49

    (19) structure -> IF expression { programme . }

    }               shift and go to state 56


state 50

    (16) funcCall -> IDENTIFIER ( paramsCall ) .

    ;               reduce using rule 16 (funcCall -> IDENTIFIER ( paramsCall ) .)
    ADD_OP          reduce using rule 16 (funcCall -> IDENTIFIER ( paramsCall ) .)
    MUL_OP          reduce using rule 16 (funcCall -> IDENTIFIER ( paramsCall ) .)
    COMP_OP         reduce using rule 16 (funcCall -> IDENTIFIER ( paramsCall ) .)
    {               reduce using rule 16 (funcCall -> IDENTIFIER ( paramsCall ) .)
    )               reduce using rule 16 (funcCall -> IDENTIFIER ( paramsCall ) .)
    ,               reduce using rule 16 (funcCall -> IDENTIFIER ( paramsCall ) .)


state 51

    (13) paramsCall -> expression , . paramsCall
    (13) paramsCall -> . expression , paramsCall
    (14) paramsCall -> . expression
    (15) paramsCall -> .
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    )               reduce using rule 15 (paramsCall -> .)
    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 40
    paramsCall                     shift and go to state 57
    funcCall                       shift and go to state 16

state 52

    (32) assignation -> GLOBAL IDENTIFIER = expression .
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ;               reduce using rule 32 (assignation -> GLOBAL IDENTIFIER = expression .)
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32


state 53

    (7) params -> IDENTIFIER . , params
    (8) params -> IDENTIFIER .

    ,               shift and go to state 58
    )               reduce using rule 8 (params -> IDENTIFIER .)


state 54

    (11) funcDec -> FUN IDENTIFIER ( params . ) { programme RETURN expression ; }
    (12) funcDec -> FUN IDENTIFIER ( params . ) { RETURN expression ; }

    )               shift and go to state 59


state 55

    (18) structure -> WHILE expression { programme } .

    PRINT           reduce using rule 18 (structure -> WHILE expression { programme } .)
    WHILE           reduce using rule 18 (structure -> WHILE expression { programme } .)
    IF              reduce using rule 18 (structure -> WHILE expression { programme } .)
    IDENTIFIER      reduce using rule 18 (structure -> WHILE expression { programme } .)
    GLOBAL          reduce using rule 18 (structure -> WHILE expression { programme } .)
    FUN             reduce using rule 18 (structure -> WHILE expression { programme } .)
    $end            reduce using rule 18 (structure -> WHILE expression { programme } .)
    }               reduce using rule 18 (structure -> WHILE expression { programme } .)
    RETURN          reduce using rule 18 (structure -> WHILE expression { programme } .)


state 56

    (19) structure -> IF expression { programme } .

    PRINT           reduce using rule 19 (structure -> IF expression { programme } .)
    WHILE           reduce using rule 19 (structure -> IF expression { programme } .)
    IF              reduce using rule 19 (structure -> IF expression { programme } .)
    IDENTIFIER      reduce using rule 19 (structure -> IF expression { programme } .)
    GLOBAL          reduce using rule 19 (structure -> IF expression { programme } .)
    FUN             reduce using rule 19 (structure -> IF expression { programme } .)
    $end            reduce using rule 19 (structure -> IF expression { programme } .)
    }               reduce using rule 19 (structure -> IF expression { programme } .)
    RETURN          reduce using rule 19 (structure -> IF expression { programme } .)


state 57

    (13) paramsCall -> expression , paramsCall .

    )               reduce using rule 13 (paramsCall -> expression , paramsCall .)


state 58

    (7) params -> IDENTIFIER , . params
    (7) params -> . IDENTIFIER , params
    (8) params -> . IDENTIFIER
    (9) params -> .

    IDENTIFIER      shift and go to state 53
    )               reduce using rule 9 (params -> .)

    params                         shift and go to state 60

state 59

    (11) funcDec -> FUN IDENTIFIER ( params ) . { programme RETURN expression ; }
    (12) funcDec -> FUN IDENTIFIER ( params ) . { RETURN expression ; }

    {               shift and go to state 61


state 60

    (7) params -> IDENTIFIER , params .

    )               reduce using rule 7 (params -> IDENTIFIER , params .)


state 61

    (11) funcDec -> FUN IDENTIFIER ( params ) { . programme RETURN expression ; }
    (12) funcDec -> FUN IDENTIFIER ( params ) { . RETURN expression ; }
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (17) statement -> . PRINT expression
    (10) structure -> . funcDec
    (18) structure -> . WHILE expression { programme }
    (19) structure -> . IF expression { programme }
    (31) assignation -> . IDENTIFIER = expression
    (32) assignation -> . GLOBAL IDENTIFIER = expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )
    (11) funcDec -> . FUN IDENTIFIER ( params ) { programme RETURN expression ; }
    (12) funcDec -> . FUN IDENTIFIER ( params ) { RETURN expression ; }

    RETURN          shift and go to state 63
    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 62
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 62

    (11) funcDec -> FUN IDENTIFIER ( params ) { programme . RETURN expression ; }

    RETURN          shift and go to state 64


state 63

    (12) funcDec -> FUN IDENTIFIER ( params ) { RETURN . expression ; }
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 65
    funcCall                       shift and go to state 16

state 64

    (11) funcDec -> FUN IDENTIFIER ( params ) { programme RETURN . expression ; }
    (20) expression -> . funcCall
    (21) expression -> . STRING + STRING
    (22) expression -> . expression ADD_OP expression
    (23) expression -> . expression MUL_OP expression
    (24) expression -> . expression COMP_OP expression
    (25) expression -> . NUMBER
    (26) expression -> . IDENTIFIER
    (27) expression -> . BOOLEAN
    (28) expression -> . STRING
    (29) expression -> . ( expression )
    (30) expression -> . ADD_OP expression
    (16) funcCall -> . IDENTIFIER ( paramsCall )

    STRING          shift and go to state 17
    NUMBER          shift and go to state 19
    IDENTIFIER      shift and go to state 20
    BOOLEAN         shift and go to state 21
    (               shift and go to state 22
    ADD_OP          shift and go to state 18

    expression                     shift and go to state 66
    funcCall                       shift and go to state 16

state 65

    (12) funcDec -> FUN IDENTIFIER ( params ) { RETURN expression . ; }
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ;               shift and go to state 67
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32


state 66

    (11) funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression . ; }
    (22) expression -> expression . ADD_OP expression
    (23) expression -> expression . MUL_OP expression
    (24) expression -> expression . COMP_OP expression

    ;               shift and go to state 68
    ADD_OP          shift and go to state 30
    MUL_OP          shift and go to state 31
    COMP_OP         shift and go to state 32


state 67

    (12) funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; . }

    }               shift and go to state 69


state 68

    (11) funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; . }

    }               shift and go to state 70


state 69

    (12) funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .

    PRINT           reduce using rule 12 (funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .)
    WHILE           reduce using rule 12 (funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .)
    IF              reduce using rule 12 (funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .)
    IDENTIFIER      reduce using rule 12 (funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .)
    GLOBAL          reduce using rule 12 (funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .)
    FUN             reduce using rule 12 (funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .)
    $end            reduce using rule 12 (funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .)
    }               reduce using rule 12 (funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .)
    RETURN          reduce using rule 12 (funcDec -> FUN IDENTIFIER ( params ) { RETURN expression ; } .)


state 70

    (11) funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .

    PRINT           reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .)
    WHILE           reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .)
    IF              reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .)
    IDENTIFIER      reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .)
    GLOBAL          reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .)
    FUN             reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .)
    $end            reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .)
    }               reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .)
    RETURN          reduce using rule 11 (funcDec -> FUN IDENTIFIER ( params ) { programme RETURN expression ; } .)

