Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programme
Rule 1     programme -> statement ; programme
Rule 2     programme -> structure programme
Rule 3     programme -> statement ;
Rule 4     programme -> structure
Rule 5     statement -> assignation
Rule 6     statement -> funcCall
Rule 7     structure -> funcDec
Rule 8     funcDec -> FUN IDENTIFIER ( ) { programme }
Rule 9     funcCall -> IDENTIFIER ( )
Rule 10    statement -> PRINT expression
Rule 11    structure -> WHILE expression { programme }
Rule 12    structure -> IF expression { programme }
Rule 13    expression -> STRING + STRING
Rule 14    expression -> expression ADD_OP expression
Rule 15    expression -> expression MUL_OP expression
Rule 16    expression -> expression COMP_OP expression
Rule 17    expression -> NUMBER
Rule 18    expression -> IDENTIFIER
Rule 19    expression -> BOOLEAN
Rule 20    expression -> STRING
Rule 21    expression -> ( expression )
Rule 22    expression -> ADD_OP expression
Rule 23    assignation -> IDENTIFIER = expression
Rule 24    assignation -> GLOBAL IDENTIFIER = expression

Terminals, with rules where they appear

(                    : 8 9 21
)                    : 8 9 21
+                    : 13
;                    : 1 3
=                    : 23 24
ADD_OP               : 14 22
BOOLEAN              : 19
COMP_OP              : 16
FUN                  : 8
GLOBAL               : 24
IDENTIFIER           : 8 9 18 23 24
IF                   : 12
MUL_OP               : 15
NUMBER               : 17
PRINT                : 10
STRING               : 13 13 20
WHILE                : 11
error                : 
{                    : 8 11 12
}                    : 8 11 12

Nonterminals, with rules where they appear

assignation          : 5
expression           : 10 11 12 14 14 15 15 16 16 21 22 23 24
funcCall             : 6
funcDec              : 7
programme            : 1 2 8 11 12 0
statement            : 1 3
structure            : 2 4

Parsing method: LALR

state 0

    (0) S' -> . programme
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (10) statement -> . PRINT expression
    (7) structure -> . funcDec
    (11) structure -> . WHILE expression { programme }
    (12) structure -> . IF expression { programme }
    (23) assignation -> . IDENTIFIER = expression
    (24) assignation -> . GLOBAL IDENTIFIER = expression
    (9) funcCall -> . IDENTIFIER ( )
    (8) funcDec -> . FUN IDENTIFIER ( ) { programme }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 1
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 1

    (0) S' -> programme .



state 2

    (1) programme -> statement . ; programme
    (3) programme -> statement . ;

    ;               shift and go to state 13


state 3

    (2) programme -> structure . programme
    (4) programme -> structure .
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (10) statement -> . PRINT expression
    (7) structure -> . funcDec
    (11) structure -> . WHILE expression { programme }
    (12) structure -> . IF expression { programme }
    (23) assignation -> . IDENTIFIER = expression
    (24) assignation -> . GLOBAL IDENTIFIER = expression
    (9) funcCall -> . IDENTIFIER ( )
    (8) funcDec -> . FUN IDENTIFIER ( ) { programme }

    $end            reduce using rule 4 (programme -> structure .)
    }               reduce using rule 4 (programme -> structure .)
    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    structure                      shift and go to state 3
    programme                      shift and go to state 14
    statement                      shift and go to state 2
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 4

    (5) statement -> assignation .

    ;               reduce using rule 5 (statement -> assignation .)


state 5

    (6) statement -> funcCall .

    ;               reduce using rule 6 (statement -> funcCall .)


state 6

    (10) statement -> PRINT . expression
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 15

state 7

    (7) structure -> funcDec .

    PRINT           reduce using rule 7 (structure -> funcDec .)
    WHILE           reduce using rule 7 (structure -> funcDec .)
    IF              reduce using rule 7 (structure -> funcDec .)
    IDENTIFIER      reduce using rule 7 (structure -> funcDec .)
    GLOBAL          reduce using rule 7 (structure -> funcDec .)
    FUN             reduce using rule 7 (structure -> funcDec .)
    $end            reduce using rule 7 (structure -> funcDec .)
    }               reduce using rule 7 (structure -> funcDec .)


state 8

    (11) structure -> WHILE . expression { programme }
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 22

state 9

    (12) structure -> IF . expression { programme }
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 23

state 10

    (23) assignation -> IDENTIFIER . = expression
    (9) funcCall -> IDENTIFIER . ( )

    =               shift and go to state 24
    (               shift and go to state 25


state 11

    (24) assignation -> GLOBAL . IDENTIFIER = expression

    IDENTIFIER      shift and go to state 26


state 12

    (8) funcDec -> FUN . IDENTIFIER ( ) { programme }

    IDENTIFIER      shift and go to state 27


state 13

    (1) programme -> statement ; . programme
    (3) programme -> statement ; .
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (10) statement -> . PRINT expression
    (7) structure -> . funcDec
    (11) structure -> . WHILE expression { programme }
    (12) structure -> . IF expression { programme }
    (23) assignation -> . IDENTIFIER = expression
    (24) assignation -> . GLOBAL IDENTIFIER = expression
    (9) funcCall -> . IDENTIFIER ( )
    (8) funcDec -> . FUN IDENTIFIER ( ) { programme }

    $end            reduce using rule 3 (programme -> statement ; .)
    }               reduce using rule 3 (programme -> statement ; .)
    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    statement                      shift and go to state 2
    programme                      shift and go to state 28
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 14

    (2) programme -> structure programme .

    $end            reduce using rule 2 (programme -> structure programme .)
    }               reduce using rule 2 (programme -> structure programme .)


state 15

    (10) statement -> PRINT expression .
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    ;               reduce using rule 10 (statement -> PRINT expression .)
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 16

    (13) expression -> STRING . + STRING
    (20) expression -> STRING .

    +               shift and go to state 32
    ADD_OP          reduce using rule 20 (expression -> STRING .)
    MUL_OP          reduce using rule 20 (expression -> STRING .)
    COMP_OP         reduce using rule 20 (expression -> STRING .)
    ;               reduce using rule 20 (expression -> STRING .)
    {               reduce using rule 20 (expression -> STRING .)
    )               reduce using rule 20 (expression -> STRING .)


state 17

    (22) expression -> ADD_OP . expression
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 33

state 18

    (17) expression -> NUMBER .

    ADD_OP          reduce using rule 17 (expression -> NUMBER .)
    MUL_OP          reduce using rule 17 (expression -> NUMBER .)
    COMP_OP         reduce using rule 17 (expression -> NUMBER .)
    ;               reduce using rule 17 (expression -> NUMBER .)
    {               reduce using rule 17 (expression -> NUMBER .)
    )               reduce using rule 17 (expression -> NUMBER .)


state 19

    (18) expression -> IDENTIFIER .

    ADD_OP          reduce using rule 18 (expression -> IDENTIFIER .)
    MUL_OP          reduce using rule 18 (expression -> IDENTIFIER .)
    COMP_OP         reduce using rule 18 (expression -> IDENTIFIER .)
    ;               reduce using rule 18 (expression -> IDENTIFIER .)
    {               reduce using rule 18 (expression -> IDENTIFIER .)
    )               reduce using rule 18 (expression -> IDENTIFIER .)


state 20

    (19) expression -> BOOLEAN .

    ADD_OP          reduce using rule 19 (expression -> BOOLEAN .)
    MUL_OP          reduce using rule 19 (expression -> BOOLEAN .)
    COMP_OP         reduce using rule 19 (expression -> BOOLEAN .)
    ;               reduce using rule 19 (expression -> BOOLEAN .)
    {               reduce using rule 19 (expression -> BOOLEAN .)
    )               reduce using rule 19 (expression -> BOOLEAN .)


state 21

    (21) expression -> ( . expression )
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 34

state 22

    (11) structure -> WHILE expression . { programme }
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    {               shift and go to state 35
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 23

    (12) structure -> IF expression . { programme }
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    {               shift and go to state 36
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 24

    (23) assignation -> IDENTIFIER = . expression
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 37

state 25

    (9) funcCall -> IDENTIFIER ( . )

    )               shift and go to state 38


state 26

    (24) assignation -> GLOBAL IDENTIFIER . = expression

    =               shift and go to state 39


state 27

    (8) funcDec -> FUN IDENTIFIER . ( ) { programme }

    (               shift and go to state 40


state 28

    (1) programme -> statement ; programme .

    $end            reduce using rule 1 (programme -> statement ; programme .)
    }               reduce using rule 1 (programme -> statement ; programme .)


state 29

    (14) expression -> expression ADD_OP . expression
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 41

state 30

    (15) expression -> expression MUL_OP . expression
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 42

state 31

    (16) expression -> expression COMP_OP . expression
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 43

state 32

    (13) expression -> STRING + . STRING

    STRING          shift and go to state 44


state 33

    (22) expression -> ADD_OP expression .
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 22 (expression -> ADD_OP expression .)
    MUL_OP          reduce using rule 22 (expression -> ADD_OP expression .)
    COMP_OP         reduce using rule 22 (expression -> ADD_OP expression .)
    ;               reduce using rule 22 (expression -> ADD_OP expression .)
    {               reduce using rule 22 (expression -> ADD_OP expression .)
    )               reduce using rule 22 (expression -> ADD_OP expression .)

  ! ADD_OP          [ shift and go to state 29 ]
  ! MUL_OP          [ shift and go to state 30 ]
  ! COMP_OP         [ shift and go to state 31 ]


state 34

    (21) expression -> ( expression . )
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    )               shift and go to state 45
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 35

    (11) structure -> WHILE expression { . programme }
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (10) statement -> . PRINT expression
    (7) structure -> . funcDec
    (11) structure -> . WHILE expression { programme }
    (12) structure -> . IF expression { programme }
    (23) assignation -> . IDENTIFIER = expression
    (24) assignation -> . GLOBAL IDENTIFIER = expression
    (9) funcCall -> . IDENTIFIER ( )
    (8) funcDec -> . FUN IDENTIFIER ( ) { programme }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 46
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 36

    (12) structure -> IF expression { . programme }
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (10) statement -> . PRINT expression
    (7) structure -> . funcDec
    (11) structure -> . WHILE expression { programme }
    (12) structure -> . IF expression { programme }
    (23) assignation -> . IDENTIFIER = expression
    (24) assignation -> . GLOBAL IDENTIFIER = expression
    (9) funcCall -> . IDENTIFIER ( )
    (8) funcDec -> . FUN IDENTIFIER ( ) { programme }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 47
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 37

    (23) assignation -> IDENTIFIER = expression .
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    ;               reduce using rule 23 (assignation -> IDENTIFIER = expression .)
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 38

    (9) funcCall -> IDENTIFIER ( ) .

    ;               reduce using rule 9 (funcCall -> IDENTIFIER ( ) .)


state 39

    (24) assignation -> GLOBAL IDENTIFIER = . expression
    (13) expression -> . STRING + STRING
    (14) expression -> . expression ADD_OP expression
    (15) expression -> . expression MUL_OP expression
    (16) expression -> . expression COMP_OP expression
    (17) expression -> . NUMBER
    (18) expression -> . IDENTIFIER
    (19) expression -> . BOOLEAN
    (20) expression -> . STRING
    (21) expression -> . ( expression )
    (22) expression -> . ADD_OP expression

    STRING          shift and go to state 16
    NUMBER          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    BOOLEAN         shift and go to state 20
    (               shift and go to state 21
    ADD_OP          shift and go to state 17

    expression                     shift and go to state 48

state 40

    (8) funcDec -> FUN IDENTIFIER ( . ) { programme }

    )               shift and go to state 49


state 41

    (14) expression -> expression ADD_OP expression .
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 14 (expression -> expression ADD_OP expression .)
    ;               reduce using rule 14 (expression -> expression ADD_OP expression .)
    {               reduce using rule 14 (expression -> expression ADD_OP expression .)
    )               reduce using rule 14 (expression -> expression ADD_OP expression .)
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31

  ! MUL_OP          [ reduce using rule 14 (expression -> expression ADD_OP expression .) ]
  ! COMP_OP         [ reduce using rule 14 (expression -> expression ADD_OP expression .) ]
  ! ADD_OP          [ shift and go to state 29 ]


state 42

    (15) expression -> expression MUL_OP expression .
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 15 (expression -> expression MUL_OP expression .)
    MUL_OP          reduce using rule 15 (expression -> expression MUL_OP expression .)
    ;               reduce using rule 15 (expression -> expression MUL_OP expression .)
    {               reduce using rule 15 (expression -> expression MUL_OP expression .)
    )               reduce using rule 15 (expression -> expression MUL_OP expression .)
    COMP_OP         shift and go to state 31

  ! COMP_OP         [ reduce using rule 15 (expression -> expression MUL_OP expression .) ]
  ! ADD_OP          [ shift and go to state 29 ]
  ! MUL_OP          [ shift and go to state 30 ]


state 43

    (16) expression -> expression COMP_OP expression .
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    ADD_OP          reduce using rule 16 (expression -> expression COMP_OP expression .)
    MUL_OP          reduce using rule 16 (expression -> expression COMP_OP expression .)
    COMP_OP         reduce using rule 16 (expression -> expression COMP_OP expression .)
    ;               reduce using rule 16 (expression -> expression COMP_OP expression .)
    {               reduce using rule 16 (expression -> expression COMP_OP expression .)
    )               reduce using rule 16 (expression -> expression COMP_OP expression .)

  ! ADD_OP          [ shift and go to state 29 ]
  ! MUL_OP          [ shift and go to state 30 ]
  ! COMP_OP         [ shift and go to state 31 ]


state 44

    (13) expression -> STRING + STRING .

    ADD_OP          reduce using rule 13 (expression -> STRING + STRING .)
    MUL_OP          reduce using rule 13 (expression -> STRING + STRING .)
    COMP_OP         reduce using rule 13 (expression -> STRING + STRING .)
    ;               reduce using rule 13 (expression -> STRING + STRING .)
    {               reduce using rule 13 (expression -> STRING + STRING .)
    )               reduce using rule 13 (expression -> STRING + STRING .)


state 45

    (21) expression -> ( expression ) .

    ADD_OP          reduce using rule 21 (expression -> ( expression ) .)
    MUL_OP          reduce using rule 21 (expression -> ( expression ) .)
    COMP_OP         reduce using rule 21 (expression -> ( expression ) .)
    ;               reduce using rule 21 (expression -> ( expression ) .)
    {               reduce using rule 21 (expression -> ( expression ) .)
    )               reduce using rule 21 (expression -> ( expression ) .)


state 46

    (11) structure -> WHILE expression { programme . }

    }               shift and go to state 50


state 47

    (12) structure -> IF expression { programme . }

    }               shift and go to state 51


state 48

    (24) assignation -> GLOBAL IDENTIFIER = expression .
    (14) expression -> expression . ADD_OP expression
    (15) expression -> expression . MUL_OP expression
    (16) expression -> expression . COMP_OP expression

    ;               reduce using rule 24 (assignation -> GLOBAL IDENTIFIER = expression .)
    ADD_OP          shift and go to state 29
    MUL_OP          shift and go to state 30
    COMP_OP         shift and go to state 31


state 49

    (8) funcDec -> FUN IDENTIFIER ( ) . { programme }

    {               shift and go to state 52


state 50

    (11) structure -> WHILE expression { programme } .

    PRINT           reduce using rule 11 (structure -> WHILE expression { programme } .)
    WHILE           reduce using rule 11 (structure -> WHILE expression { programme } .)
    IF              reduce using rule 11 (structure -> WHILE expression { programme } .)
    IDENTIFIER      reduce using rule 11 (structure -> WHILE expression { programme } .)
    GLOBAL          reduce using rule 11 (structure -> WHILE expression { programme } .)
    FUN             reduce using rule 11 (structure -> WHILE expression { programme } .)
    $end            reduce using rule 11 (structure -> WHILE expression { programme } .)
    }               reduce using rule 11 (structure -> WHILE expression { programme } .)


state 51

    (12) structure -> IF expression { programme } .

    PRINT           reduce using rule 12 (structure -> IF expression { programme } .)
    WHILE           reduce using rule 12 (structure -> IF expression { programme } .)
    IF              reduce using rule 12 (structure -> IF expression { programme } .)
    IDENTIFIER      reduce using rule 12 (structure -> IF expression { programme } .)
    GLOBAL          reduce using rule 12 (structure -> IF expression { programme } .)
    FUN             reduce using rule 12 (structure -> IF expression { programme } .)
    $end            reduce using rule 12 (structure -> IF expression { programme } .)
    }               reduce using rule 12 (structure -> IF expression { programme } .)


state 52

    (8) funcDec -> FUN IDENTIFIER ( ) { . programme }
    (1) programme -> . statement ; programme
    (2) programme -> . structure programme
    (3) programme -> . statement ;
    (4) programme -> . structure
    (5) statement -> . assignation
    (6) statement -> . funcCall
    (10) statement -> . PRINT expression
    (7) structure -> . funcDec
    (11) structure -> . WHILE expression { programme }
    (12) structure -> . IF expression { programme }
    (23) assignation -> . IDENTIFIER = expression
    (24) assignation -> . GLOBAL IDENTIFIER = expression
    (9) funcCall -> . IDENTIFIER ( )
    (8) funcDec -> . FUN IDENTIFIER ( ) { programme }

    PRINT           shift and go to state 6
    WHILE           shift and go to state 8
    IF              shift and go to state 9
    IDENTIFIER      shift and go to state 10
    GLOBAL          shift and go to state 11
    FUN             shift and go to state 12

    programme                      shift and go to state 53
    statement                      shift and go to state 2
    structure                      shift and go to state 3
    assignation                    shift and go to state 4
    funcCall                       shift and go to state 5
    funcDec                        shift and go to state 7

state 53

    (8) funcDec -> FUN IDENTIFIER ( ) { programme . }

    }               shift and go to state 54


state 54

    (8) funcDec -> FUN IDENTIFIER ( ) { programme } .

    PRINT           reduce using rule 8 (funcDec -> FUN IDENTIFIER ( ) { programme } .)
    WHILE           reduce using rule 8 (funcDec -> FUN IDENTIFIER ( ) { programme } .)
    IF              reduce using rule 8 (funcDec -> FUN IDENTIFIER ( ) { programme } .)
    IDENTIFIER      reduce using rule 8 (funcDec -> FUN IDENTIFIER ( ) { programme } .)
    GLOBAL          reduce using rule 8 (funcDec -> FUN IDENTIFIER ( ) { programme } .)
    FUN             reduce using rule 8 (funcDec -> FUN IDENTIFIER ( ) { programme } .)
    $end            reduce using rule 8 (funcDec -> FUN IDENTIFIER ( ) { programme } .)
    }               reduce using rule 8 (funcDec -> FUN IDENTIFIER ( ) { programme } .)

